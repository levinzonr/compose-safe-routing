{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview A code generating library, inspired by SafeArgs for Android. Entrily based on the Jetpack Compose Navigation Component, SafeRoute uses its apis to ensure type-safety during navigation and allows you to define your navigation graphs without boilerplate code, hardcoded strings and more. Features Removes code duplication when describing your routes and its arguments through out the application Helper functions to declare your Routes using RouteSpec interface Support for Accompanist Animation/Material libraries Helper functions that will allow to obtain passed arguments easily, both in your Composables and ViewModel using CompositionLocal and SavedStateHandle respectivly Safety during navigation: The arguments you declared are always passed and obtained in a type-safe way Mandatory & Optional parameters Setup in your project level build.gradle allprojects { repositories { ... maven { url 'https://jitpack.io' } } } And then in you app level build.gradle dependencies { // add either KAPT or KSP processor ksp ( \"com.github.levinzonr.compose-safe-routing:processor-ksp:2.5.0\" ) kapt ( \"com.github.levinzonr.compose-safe-routing:processor-kapt:2.5.0\" ) implementation ( \"com.github.levinzonr.compose-safe-routing:core:2.5.0\" ) // or in case you are using animation/material routes from accompanist implementation ( \"com.github.levinzonr.compose-safe-routing:accompanist-navigation:2.5.0\" ) } if you are using KSP , make sure you are also added KSP build folder applicationVariants.all { variant -> kotlin.sourceSets { getByName(variant.name) { kotlin.srcDir(\"build/generated/ksp/${variant.name}/kotlin\") } } } applicationVariants.all { kotlin.sourceSets { getByName(name) { kotlin.srcDir(\"build/generated/ksp/$name/kotlin\") } } } Basic Usage At the core of the SafeRoute there is a @Route annotation. This annotation is used to describe your composable destination. Here is the basic setup for the Profile Screen @Route ( name = \"profile\" ) @Composable fun ProfileScreen () { /** your screen */ } Next you might want to add some arguments to your route. This is done using @RouteArg annotation. It takes a name and the type of the param. Here you can also specify whether or not the argument is optional. This will determine how argument will be attached to the path and if default value should be used. Note that due to Annotations limitations the default value is passed as String and then casted to the type specifed. @Composable @Route ( \"details\" , args = [ RouteArg ( \"id\" , String :: class , isOptional = false ), RouteArg ( \"number\" , Int :: class , isOptional = true , defaultValue = \"1\" ), ] ) fun DetailsScreen () { /** sweet composable code ** / } After you build the project, SafeRoute will generate multiple files based on the @Route annotations. These files now fully describe your Routes and can be used to describe you navigation graph easier and to navigate from one Route to another. NavHost ( startDestination = Routes . Profile . route ) { composable ( ProfieRoute ) { ProfileScreen ( onShowDetails = { // navController extension used to navigate navController . navigateTo ( DetailsRoute ( id = \"hello\" )) }) } composable ( DetailsRoute ) { // get the arguments val args = LocalDetailsRouteArgs . current DetailsScreen ( args ) } }","title":"Overview"},{"location":"#overview","text":"A code generating library, inspired by SafeArgs for Android. Entrily based on the Jetpack Compose Navigation Component, SafeRoute uses its apis to ensure type-safety during navigation and allows you to define your navigation graphs without boilerplate code, hardcoded strings and more.","title":"Overview"},{"location":"#features","text":"Removes code duplication when describing your routes and its arguments through out the application Helper functions to declare your Routes using RouteSpec interface Support for Accompanist Animation/Material libraries Helper functions that will allow to obtain passed arguments easily, both in your Composables and ViewModel using CompositionLocal and SavedStateHandle respectivly Safety during navigation: The arguments you declared are always passed and obtained in a type-safe way Mandatory & Optional parameters","title":"Features"},{"location":"#setup","text":"in your project level build.gradle allprojects { repositories { ... maven { url 'https://jitpack.io' } } } And then in you app level build.gradle dependencies { // add either KAPT or KSP processor ksp ( \"com.github.levinzonr.compose-safe-routing:processor-ksp:2.5.0\" ) kapt ( \"com.github.levinzonr.compose-safe-routing:processor-kapt:2.5.0\" ) implementation ( \"com.github.levinzonr.compose-safe-routing:core:2.5.0\" ) // or in case you are using animation/material routes from accompanist implementation ( \"com.github.levinzonr.compose-safe-routing:accompanist-navigation:2.5.0\" ) } if you are using KSP , make sure you are also added KSP build folder applicationVariants.all { variant -> kotlin.sourceSets { getByName(variant.name) { kotlin.srcDir(\"build/generated/ksp/${variant.name}/kotlin\") } } } applicationVariants.all { kotlin.sourceSets { getByName(name) { kotlin.srcDir(\"build/generated/ksp/$name/kotlin\") } } }","title":"Setup"},{"location":"#basic-usage","text":"At the core of the SafeRoute there is a @Route annotation. This annotation is used to describe your composable destination. Here is the basic setup for the Profile Screen @Route ( name = \"profile\" ) @Composable fun ProfileScreen () { /** your screen */ } Next you might want to add some arguments to your route. This is done using @RouteArg annotation. It takes a name and the type of the param. Here you can also specify whether or not the argument is optional. This will determine how argument will be attached to the path and if default value should be used. Note that due to Annotations limitations the default value is passed as String and then casted to the type specifed. @Composable @Route ( \"details\" , args = [ RouteArg ( \"id\" , String :: class , isOptional = false ), RouteArg ( \"number\" , Int :: class , isOptional = true , defaultValue = \"1\" ), ] ) fun DetailsScreen () { /** sweet composable code ** / } After you build the project, SafeRoute will generate multiple files based on the @Route annotations. These files now fully describe your Routes and can be used to describe you navigation graph easier and to navigate from one Route to another. NavHost ( startDestination = Routes . Profile . route ) { composable ( ProfieRoute ) { ProfileScreen ( onShowDetails = { // navController extension used to navigate navController . navigateTo ( DetailsRoute ( id = \"hello\" )) }) } composable ( DetailsRoute ) { // get the arguments val args = LocalDetailsRouteArgs . current DetailsScreen ( args ) } }","title":"Basic Usage"},{"location":"arguments/","text":"Defining And Obtaining Arguments This page will walk you through defining arguments for your Routes, passing and obtaining them once the navigation is done. Defining Arguments Arguments are defined using @RouteArg annotations. The annotation allows you to sepcify the argument's name, type and wether it supposed to be optional or or not. Here how the annotation looks like annotation class RouteArg ( val name : String , val type : KClass <*> = String :: class , val isOptional : Boolean = false , val isNullable : Boolean = false , val defaultValue : String = AnnotationsDefaults . NULL ) Mandatory Arguments By default every described by the annotation is considered not nullable and not optional . The example bellow will generate a Route with one argument called \"id\" of a type String @Composable @Route ( args = [ RouteArgs ( name = \"id\" , type = String :: class ) ] ) fun DetailsExample () {} Optional Arguments Optional arguments can be defined using isOptional flag. When set to true, it is also required to provide the default value using the defaultValue parameter. Note, Due to the limitatoins of the Annotations classes, the default value must be String . Later on, it will be casted back to the apporpriate type. @Composable @Route ( args = [ RouteArgs ( name = \"index\" , type = Int :: class , isOptional = true , defaultValue = 1. toString () ) ] ) fun IndexExample () {} Navigation With Arguments The navigation with arugments is done in a similar fasion as it is without it. After the arugments are defined for the route, and build process is complete, the invoke() operator for the routes with arguments will change. Thus, when you change the argument name/type, you will get the compile time error every time you forget to update the navigation code, ensuring the arguments are passed all the time val navController = rememberNavController () // mandatory id navController . navigateTo ( DetailsRoute ( \"myId\" )) // optional index navController . navigateTo ( IndexRoute ()) navController . navigateTo ( IndexRoute ( index = 1 )) Obtaining Arguments Now that we've seen how to define and pass the arguments for your route, let's see how to actually obtain the value. SafeRoute provides multiple ways you can access the arguments. It is achieved using RouteArgsFactory component. interface RouteArgsFactory < T > { fun fromBundle ( bundle : Bundle?) : T fun fromSavedStateHandle ( handle : SavedStateHandle?) : T val LocalArgs : ProvidableCompositionLocal < T > } Every RouteSpec has its own RouteArgsFactory implementation. It allows you to grab your arguments either from NavBackStackEntry composable ( IndexRoute ) { entry -> val args = IndexRouteArgsFactory . fromBackStackEntry ( entry ) IndexScreen ( args ) } or SavedStateHandle that is injected in your ViewModel class DetailsViewModel ( savedStateHandle : SavedStateHandle ) : ViewModel () { val args = DetailsRouteArgsFactory . from ( savedStateHandle ) } Composition Local Additionaly, for every time you use NavGraphBuilders from SafeRoute , the arguments are saved in the CompositionLocal and can be accessed at any point inside your UI tree. composable ( IndexRoute ) { val args = LocalIndexArgs . current IndexScreen ( args ) } // or @Composable fun IndexScreen () { val args = LocalIndexArgs . current }","title":"Defining And Obtaining Arguments"},{"location":"arguments/#defining-and-obtaining-arguments","text":"This page will walk you through defining arguments for your Routes, passing and obtaining them once the navigation is done.","title":"Defining And Obtaining Arguments"},{"location":"arguments/#defining-arguments","text":"Arguments are defined using @RouteArg annotations. The annotation allows you to sepcify the argument's name, type and wether it supposed to be optional or or not. Here how the annotation looks like annotation class RouteArg ( val name : String , val type : KClass <*> = String :: class , val isOptional : Boolean = false , val isNullable : Boolean = false , val defaultValue : String = AnnotationsDefaults . NULL )","title":"Defining Arguments"},{"location":"arguments/#mandatory-arguments","text":"By default every described by the annotation is considered not nullable and not optional . The example bellow will generate a Route with one argument called \"id\" of a type String @Composable @Route ( args = [ RouteArgs ( name = \"id\" , type = String :: class ) ] ) fun DetailsExample () {}","title":"Mandatory Arguments"},{"location":"arguments/#optional-arguments","text":"Optional arguments can be defined using isOptional flag. When set to true, it is also required to provide the default value using the defaultValue parameter. Note, Due to the limitatoins of the Annotations classes, the default value must be String . Later on, it will be casted back to the apporpriate type. @Composable @Route ( args = [ RouteArgs ( name = \"index\" , type = Int :: class , isOptional = true , defaultValue = 1. toString () ) ] ) fun IndexExample () {}","title":"Optional Arguments"},{"location":"arguments/#navigation-with-arguments","text":"The navigation with arugments is done in a similar fasion as it is without it. After the arugments are defined for the route, and build process is complete, the invoke() operator for the routes with arguments will change. Thus, when you change the argument name/type, you will get the compile time error every time you forget to update the navigation code, ensuring the arguments are passed all the time val navController = rememberNavController () // mandatory id navController . navigateTo ( DetailsRoute ( \"myId\" )) // optional index navController . navigateTo ( IndexRoute ()) navController . navigateTo ( IndexRoute ( index = 1 ))","title":"Navigation With Arguments"},{"location":"arguments/#obtaining-arguments","text":"Now that we've seen how to define and pass the arguments for your route, let's see how to actually obtain the value. SafeRoute provides multiple ways you can access the arguments. It is achieved using RouteArgsFactory component. interface RouteArgsFactory < T > { fun fromBundle ( bundle : Bundle?) : T fun fromSavedStateHandle ( handle : SavedStateHandle?) : T val LocalArgs : ProvidableCompositionLocal < T > } Every RouteSpec has its own RouteArgsFactory implementation. It allows you to grab your arguments either from NavBackStackEntry composable ( IndexRoute ) { entry -> val args = IndexRouteArgsFactory . fromBackStackEntry ( entry ) IndexScreen ( args ) } or SavedStateHandle that is injected in your ViewModel class DetailsViewModel ( savedStateHandle : SavedStateHandle ) : ViewModel () { val args = DetailsRouteArgsFactory . from ( savedStateHandle ) }","title":"Obtaining Arguments"},{"location":"arguments/#composition-local","text":"Additionaly, for every time you use NavGraphBuilders from SafeRoute , the arguments are saved in the CompositionLocal and can be accessed at any point inside your UI tree. composable ( IndexRoute ) { val args = LocalIndexArgs . current IndexScreen ( args ) } // or @Composable fun IndexScreen () { val args = LocalIndexArgs . current }","title":"Composition Local"},{"location":"configuration/","text":"Configure SafeRoute If you want to customize and/or adjust the way SafeRoute works you can do so by passing arguments to the processor. Default Package name Some files, such as MainGraph , generated by SafeRoute are generated without specific relation to the package name. Their package name is based on the first element the processor encounters, which is not always ideal and can lead to unintended behaviour To fix this, you can specify the defaultPackageName where files like these will be placed kapt { arguments { arg ( \"safeRoute.defaultPackageName\" , \"cz.levinzonr.saferoute.navigation\" ) } } ksp { arg ( \"safeRoute.defaultPackageName\" , \"cz.levinzonr.saferoute.navigation\" ) }","title":"Configure SafeRoute"},{"location":"configuration/#configure-saferoute","text":"If you want to customize and/or adjust the way SafeRoute works you can do so by passing arguments to the processor.","title":"Configure SafeRoute"},{"location":"configuration/#default-package-name","text":"Some files, such as MainGraph , generated by SafeRoute are generated without specific relation to the package name. Their package name is based on the first element the processor encounters, which is not always ideal and can lead to unintended behaviour To fix this, you can specify the defaultPackageName where files like these will be placed kapt { arguments { arg ( \"safeRoute.defaultPackageName\" , \"cz.levinzonr.saferoute.navigation\" ) } } ksp { arg ( \"safeRoute.defaultPackageName\" , \"cz.levinzonr.saferoute.navigation\" ) }","title":"Default Package name"},{"location":"route/","text":"Defining Routes Defining your Routes is basic functionality provided by SafeRoute. Every generated Route implements RouteSpec interface, which contains everything Navigation Component needs to know in order to include as part of navigation graphs. interface RouteSpec < A > { /** * Fully qualified path of the Route that will be used for the navigation * In case Route will have arguments specified, this value will also contain arguments in its path */ val route : String /** * List of the NavArgs that this Route accepts */ val navArgs : List < NamedNavArgument > /** * Helper class that serves as Arguments retriever. Use this class in order to * obtainy your arguments either from the SavedStateHandle in you ViewModel or NavBackStackEntty */ val argsFactory : RouteArgsFactory < A > /** * List of the deeplink served by this Route */ val deepLinks : List < NavDeepLink > } To generate simple RouteSpec for your Route simply annotate it using @Route annotation @Route @Composable fun Home () { /* UI */ } In this example SafeRoute will generate the most basic RouteSpec with the implicit name (taken from the Name of the composable function) and a Route postfix, resulting in HomeRoute . From this point you can start adding your Route in you Navigation Graph. To do so, SafeRoute provides number of NavGraphBuilder extensions, with the names you might be familiar. They are the same as the ones provided by Jetpack Navigation Component artifact, with the only difference: Instead of passing a bunch of details to it, you can simply pass your RouteSpec There multiple builders available, learn more in our RouteTransitions doc val navController = rememberNavController () NavHost ( startDestination = HomeRoute . route ) { composable ( HomeRoute ) { Home () } } In case you want provide a different name for your route you can simply pass the name parameter as parth of the annotation @Route ( name = \"profile\" ) @Composable fun ProfileScreen () { /* UI */ } And lets our new route to the NavGraph val navController = rememberNavController () NavHost ( startDestination = HomeRoute . route ) { composable ( HomeRoute ) { Home () } composable ( ProfileRoute ) { ProfileScreen () } } Navigation Now that you have multiple Routes in your navigation graph lets explore how you can navigate from one to another. In Jetpack Compose, all destinations reresented as Strings. Using SafeRoute you can take advantage of the Direction . Direction represents a path that Navigation Component can use to navigate to your route, including every argument (if any) already serialized into string. Accessing Direction is straight forward, all you need to do is invoke() your Route navController . navigate ( ProfileRoute (). route ) SafeRoute also provides navigateTo extension that you can use to make it a bit shorter navController . navigateTo ( ProfileRoute ())","title":"Defining Routes"},{"location":"route/#defining-routes","text":"Defining your Routes is basic functionality provided by SafeRoute. Every generated Route implements RouteSpec interface, which contains everything Navigation Component needs to know in order to include as part of navigation graphs. interface RouteSpec < A > { /** * Fully qualified path of the Route that will be used for the navigation * In case Route will have arguments specified, this value will also contain arguments in its path */ val route : String /** * List of the NavArgs that this Route accepts */ val navArgs : List < NamedNavArgument > /** * Helper class that serves as Arguments retriever. Use this class in order to * obtainy your arguments either from the SavedStateHandle in you ViewModel or NavBackStackEntty */ val argsFactory : RouteArgsFactory < A > /** * List of the deeplink served by this Route */ val deepLinks : List < NavDeepLink > } To generate simple RouteSpec for your Route simply annotate it using @Route annotation @Route @Composable fun Home () { /* UI */ } In this example SafeRoute will generate the most basic RouteSpec with the implicit name (taken from the Name of the composable function) and a Route postfix, resulting in HomeRoute . From this point you can start adding your Route in you Navigation Graph. To do so, SafeRoute provides number of NavGraphBuilder extensions, with the names you might be familiar. They are the same as the ones provided by Jetpack Navigation Component artifact, with the only difference: Instead of passing a bunch of details to it, you can simply pass your RouteSpec There multiple builders available, learn more in our RouteTransitions doc val navController = rememberNavController () NavHost ( startDestination = HomeRoute . route ) { composable ( HomeRoute ) { Home () } } In case you want provide a different name for your route you can simply pass the name parameter as parth of the annotation @Route ( name = \"profile\" ) @Composable fun ProfileScreen () { /* UI */ } And lets our new route to the NavGraph val navController = rememberNavController () NavHost ( startDestination = HomeRoute . route ) { composable ( HomeRoute ) { Home () } composable ( ProfileRoute ) { ProfileScreen () } }","title":"Defining Routes"},{"location":"route/#navigation","text":"Now that you have multiple Routes in your navigation graph lets explore how you can navigate from one to another. In Jetpack Compose, all destinations reresented as Strings. Using SafeRoute you can take advantage of the Direction . Direction represents a path that Navigation Component can use to navigate to your route, including every argument (if any) already serialized into string. Accessing Direction is straight forward, all you need to do is invoke() your Route navController . navigate ( ProfileRoute (). route ) SafeRoute also provides navigateTo extension that you can use to make it a bit shorter navController . navigateTo ( ProfileRoute ())","title":"Navigation"},{"location":"transitions/","text":"Route Transitions So far we have been using default transitions in our Routes . What if you want to something more fancy? SafeRoute also supports defining those custom transitions that provides core Navigation Component and Accompanist library Using Route Builders We had already seen the default transitions in the previous chapter which is being used by composable() route builder. In a similar fashion we can also use different transitions Dialog Transition This transition will open you composable as classic pop-up dialog. Simply use the dialog route builder that uses RouteSpec<*> as a parameter fun NavGraphBuilder . myGraph () { dialog ( MyDialogRoute ) { // Composable Content } } In case you want to modify the behaviour of your dialog, you can pass your custom DialogProperties fun NavGraphBuilder . myGraph () { dialog ( MyDialogRoute properties = DialogProperties ( dismissOnBackPress = true , dismissOnClickOutside = true , securePolicy = SecureFlagPolicy . Inherit ) ) { // Composable Content } } Bottom Sheet Following transition is a part of the Accompanist Library and requires some additional setup for yor NavHost . Please refer for the Accompanist Docs for additional info. Bottom sheet transitions is realized using bottomSheet route builder fun NavGraphBuilder . myGraph () { bottomSheet ( MyBottomSheetRoute ) { // Composable Content } } Animated Transition Following transition is a part of the Accompanist Library and requires some additional setup for yor NavHost . Please refer for the Accompanist Docs for additional info. Animated Transitions provided by Accompanist allow you to specify custom animations when navigating in and out of the screen. To set it up you will have to use different NavHost . You can either use AnimatedNavHost from Accompanist or SaferRouteAnimatedNavHost provided by SafeRoute . Then you can specify your custom transitions as parameters @Composable fun MyApp () { SafeRouteAnimatedNavHost ( HomeRoute ) { composable ( routeSpec = HomeRoute , enterTransition = fadeIn () + expandIn (), exitTransition = fadeOut () + shrinkOut (), popEnterTransition = slideIn (), popExitTransition = slideOut () ) { // Composable content } } } Specifiyng Transition in Route Annotation You can also specify your Route Transition inside the annotation. Based on that parameter, code-gen will create specific Route Buidlers based on the Route and the specified transition. Lets use our basic example @Route () @Composable fun Home () { /** compose content **/ } After build step is complete, besides Route Definition we've seen already, SafeRoute will aslo create a route builder for this screen specifically. Note that since this route dont have any parameters, we can invoke this route builder without providing Home composable fun NavGraphBuilder . myGraph () { // short version home () // in case we have some params home { Home ( \"value\" )} } RouteBuilders like this are already \"transition aware\". That means that when you change your transition in the annotation, it will also be changed in the RouteBuilder after codegen step. Dialog Transition To use dialog() builder as your transition you can use DialogRouteTransition class. It provides Default implementation in case you don't need to specify any custom DialogProperties , or you can extend it for further cusomizations // Default implementation @Composable @Route ( name = \"Home\" , transition = DialogRouteTransition . Default :: class ) fun Home () {} // Custom implementation @Composable @Route ( name = \"Home2\" , transition = CustomDialogTransition :: class ) fun Home2 () {} Bottom Sheet Transition @Composable @Route ( name = \"sheet\" , transition = BottomSheetRouteTransition :: class , ) fun Sheet () {} Animated Route Transition SafeRoute provides abstract class called AnimatedRouteTransition that allows you to modify the animations. Similar to dialog transition there is also a default implementation thats using basic fadeIn() and fadeOut() Default Animated Route Transition @Route ( transition = AnimatedRouteTransition . Default :: class ) @Composable fun Helllo () {} Custom Animated Route Transition @OptIn ( ExperimentalAnimationApi :: class ) object CustomAnimatedTransition : AnimatedRouteTransition () { override val enter : RouteEnterTransition = { expandIn () } override val exit : RouteExitTransition = { shrinkOut () } override val popEnter : RouteEnterTransition = enter override val popExit : RouteExitTransition = exit } And then use it inside the annotation @Route ( transition = CustomAnimatedTransition :: class ) @Composable fun Helllo () {}","title":"Route Transitions"},{"location":"transitions/#route-transitions","text":"So far we have been using default transitions in our Routes . What if you want to something more fancy? SafeRoute also supports defining those custom transitions that provides core Navigation Component and Accompanist library","title":"Route Transitions"},{"location":"transitions/#using-route-builders","text":"We had already seen the default transitions in the previous chapter which is being used by composable() route builder. In a similar fashion we can also use different transitions","title":"Using Route Builders"},{"location":"transitions/#dialog-transition","text":"This transition will open you composable as classic pop-up dialog. Simply use the dialog route builder that uses RouteSpec<*> as a parameter fun NavGraphBuilder . myGraph () { dialog ( MyDialogRoute ) { // Composable Content } } In case you want to modify the behaviour of your dialog, you can pass your custom DialogProperties fun NavGraphBuilder . myGraph () { dialog ( MyDialogRoute properties = DialogProperties ( dismissOnBackPress = true , dismissOnClickOutside = true , securePolicy = SecureFlagPolicy . Inherit ) ) { // Composable Content } }","title":"Dialog Transition"},{"location":"transitions/#bottom-sheet","text":"Following transition is a part of the Accompanist Library and requires some additional setup for yor NavHost . Please refer for the Accompanist Docs for additional info. Bottom sheet transitions is realized using bottomSheet route builder fun NavGraphBuilder . myGraph () { bottomSheet ( MyBottomSheetRoute ) { // Composable Content } }","title":"Bottom Sheet"},{"location":"transitions/#animated-transition","text":"Following transition is a part of the Accompanist Library and requires some additional setup for yor NavHost . Please refer for the Accompanist Docs for additional info. Animated Transitions provided by Accompanist allow you to specify custom animations when navigating in and out of the screen. To set it up you will have to use different NavHost . You can either use AnimatedNavHost from Accompanist or SaferRouteAnimatedNavHost provided by SafeRoute . Then you can specify your custom transitions as parameters @Composable fun MyApp () { SafeRouteAnimatedNavHost ( HomeRoute ) { composable ( routeSpec = HomeRoute , enterTransition = fadeIn () + expandIn (), exitTransition = fadeOut () + shrinkOut (), popEnterTransition = slideIn (), popExitTransition = slideOut () ) { // Composable content } } }","title":"Animated Transition"},{"location":"transitions/#specifiyng-transition-in-route-annotation","text":"You can also specify your Route Transition inside the annotation. Based on that parameter, code-gen will create specific Route Buidlers based on the Route and the specified transition. Lets use our basic example @Route () @Composable fun Home () { /** compose content **/ } After build step is complete, besides Route Definition we've seen already, SafeRoute will aslo create a route builder for this screen specifically. Note that since this route dont have any parameters, we can invoke this route builder without providing Home composable fun NavGraphBuilder . myGraph () { // short version home () // in case we have some params home { Home ( \"value\" )} } RouteBuilders like this are already \"transition aware\". That means that when you change your transition in the annotation, it will also be changed in the RouteBuilder after codegen step.","title":"Specifiyng Transition in Route Annotation"},{"location":"transitions/#dialog-transition_1","text":"To use dialog() builder as your transition you can use DialogRouteTransition class. It provides Default implementation in case you don't need to specify any custom DialogProperties , or you can extend it for further cusomizations // Default implementation @Composable @Route ( name = \"Home\" , transition = DialogRouteTransition . Default :: class ) fun Home () {} // Custom implementation @Composable @Route ( name = \"Home2\" , transition = CustomDialogTransition :: class ) fun Home2 () {}","title":"Dialog Transition"},{"location":"transitions/#bottom-sheet-transition","text":"@Composable @Route ( name = \"sheet\" , transition = BottomSheetRouteTransition :: class , ) fun Sheet () {}","title":"Bottom Sheet Transition"},{"location":"transitions/#animated-route-transition","text":"SafeRoute provides abstract class called AnimatedRouteTransition that allows you to modify the animations. Similar to dialog transition there is also a default implementation thats using basic fadeIn() and fadeOut()","title":"Animated Route Transition"},{"location":"transitions/#default-animated-route-transition","text":"@Route ( transition = AnimatedRouteTransition . Default :: class ) @Composable fun Helllo () {}","title":"Default Animated Route Transition"},{"location":"transitions/#custom-animated-route-transition","text":"@OptIn ( ExperimentalAnimationApi :: class ) object CustomAnimatedTransition : AnimatedRouteTransition () { override val enter : RouteEnterTransition = { expandIn () } override val exit : RouteExitTransition = { shrinkOut () } override val popEnter : RouteEnterTransition = enter override val popExit : RouteExitTransition = exit } And then use it inside the annotation @Route ( transition = CustomAnimatedTransition :: class ) @Composable fun Helllo () {}","title":"Custom Animated Route Transition"}]}